第2章 QRunes基本类型与变量
===========================

2.1 QRunes的基本对象类型
---------------------------

2.1.1 量子类型 Quantum Type
++++++++++++++++++++++++++++++

量子类型的对象描述的是量子芯片上的量子比特。

例如：qubit q;

它在运行期间会映射某一个量子芯片上的量子比特。这种对象只能被最终用于量子逻辑门操作中。它的赋值相当于创建这个映射的别名，并非描述其中的数据的复制。

2.1.2 辅助类型 Auxiliary Type 
+++++++++++++++++++++++++++++++++++++++++++

辅助类型是为了更方便创建量子操作的辅助对象。它在编译后的程序中不存在。它可以用于描述一些用于决定量子程序构造的变量或者常量。它也可以是一个编译期间的if判断或者for循环。

对于一组qubit，例如vector<qubit> qs，我们要创建作用在它们上面的Hadamard门，我们可以利用如下语句：

::

    for (i = 0: qs.size())  

    H(qs[i]);

这一组语句是一个典型的for循环，但是执行这个程序的时机是在编译期间，因此这个for循环并不是在量子计算机中运行的for循环。它的效果相当于全部展开。即：

:: 

    H(q[0]);  
    H(q[1]);  
    H(q[2]);  
    ...


2.1.3 经典类型 Classical Type
++++++++++++++++++++++++++++++++

经典类型是在量子测控系统中存在的对象。他们的创建、计算、管理都是由量子芯片的测控系统完成的。这个系统具有实时性的特点，因此这些变量的生命周期和qubit的退相干时间共存。它是为了解决普通的宿主机和量子芯片之间无法进行实时数据交换的问题而存在的。简而言之，它们介于宿主机（辅助类型）和量子芯片（量子类型）之间。

经典类型的变量典型地可以被用于保存量子比特的测量结果。除此之外，由测量结果决定的IF和WHILE操作，即后面会提到的QIF，QWHILE操作也是在测控系统中完成的，所以也属于经典类型。要注意到QIF和QWHILE和宿主机（辅助类型）的if，for，while等操作具有完全不同的运行时机，其中辅助类型的变量、表达式、语句等是编译期间计算的，经典类型是运行期间计算的。

例如：

::

    cbit c;  
    qubit q;  
    H(q);  
    Measure(q,c);  
    qif(c){  
        // do something...  
    }

这个程序就根据一个qubit在执行完Hadamard门之后进行的测量的结果来选择执行分支。注意到c是一个在测控系统中存在的变量，而qif的判断也是在这个系统中实时完成的，之间与宿主机不会发生数据传输。

经典变量之间还可以进行计算，比如：

::
    
    qif(!c) {} // 对c求非  
    qif(c1 == c2) {} //比较c1与c2的值  
    qif(c1 == True) {} //等价于qif(c1) 

但是经典辅助的if中是绝对不允许存在经典类型的变量的，原因是辅助类型的值是要求编译期间能够完全确定的，例如：

::

    if(c) // Error：编译期间无法判断c的值

2.2 常量
------------

2.3 变量  
------------

变量的定义分为两个部分来说明：

1.形参变量

形参变量，只做变量声明，由传递函数的实参进行初始化，作用域为所在函数体内，当函数结束的时候，形参即被销毁。
形参变量的格式： 变量类型 变量名
当前QRunes支持的形参变量类型有：

=============== ======================
  int                Hamiltionian
  float            variationalCircuit
  double                  var
  bool                 circuitGen
  map
  qubit  
  cbit  
  vector 
=============== ======================

2.变量

在QRunes中变量的定义分为三部分来说明：

a.量子类型的变量。

格式：量子类型 变量名
比如：

::

    qubit q; => q = allocMany(1);  
    vector<qubit> qvec;

b.经典辅助类型的变量。 

格式：let 变量名 = 初始值    
在辅助类型中的let关键字作用是定义并初始化辅助类型的变量。（占位符也是自动类型推断）。  
其中变量的类型由量子编译器根据初始值来推断确定变量的类型。  
这样做的好处： 

1).简化量子编程的编程操作，并使代码简介。（凡是辅助类型的变量直接用let关键字来定义）    

2).let关键字涉及的行为只在编译期间，而不是运行期间  

注意：  

1.let 关键字定义的变量必须有初始值。  

::

    let a; //ERROR  
    let a = 3.14; //CORRECT 

2.函数参数不可以被声明为 let。 

::

    ker(qubit q,let a){ //ERROR  
        ...  
    }  

3.let不能与其他类型组合连用。

::

    let int a = 0.09; //ERROR  

4.定义一个let关键字序列的对象的变量，其所有初始值必须为最终能推导为同一类型。  

::

    let a = 0.09, b = false, c =10; //ERROR  
    let a = 0.09, b = 3.14, c=100.901; //CORRECT  

c.经典类型的变量。

格式：经典类型 变量名  
比如：

::

    cbit c;  