6.9 QPE算法
==============

6.9.1 QPE算法介绍
--------------------

QPE算法（Quantum Phase Estimation），量子相位估计算法。该算法在很早就已经被提出了，然而真正带来很大影响的，就是基于它实现的HHL算法，以及各种基于HHL算法实现的量子机器学习算法。
相位估计最神奇的效果是达到了相比传统计算机上运行的算法的一个指数加速。这个效果怎么理解，举个简单的例子，就是传统计算机上要运行2的30次方（约等于10亿）次运算，量子计算机上只要运行30次左右就OK了。当然这个指数加速效果是有前提条件的，就是输入和输出都需要是量子比特，而量子比特怎么和经典比特对应起来呢，这又是另外一个问题了。我们只要知道，在算法的运算过程中，是有一个指数加速的效果就可以了。而这个算法凭借它的优势，可以用在很多应用上，比如求阶问题，因子分解问题以及量子机器学习HHL算法等等。

6.9.2 QPE算法的实现
---------------------

下面给出 QRunes 实现 QPE 算法的代码示例：

::

    @settings:
        language = Python;
        autoimport = True;
        compile_only = False;
        
    @qcodes:
    QCircuit QFT(qvec q) {
        for(let i=0: 1: q.size()) {
            H(q[q.size()-1-i]);
            for (let j=i+1: 1: q.size()) {
                CR(q[q.size()-1-j],
                    q[q.size()-1-i], 2*Pi/(1<<(j-i+1)));
            }
        }
    }

    QCircuit QFTdagger(qvec q) {
        QFT(q).dagger();
    }

    QCircuit unitary(qvec q) {
        RX(q[0], -Pi);
    }

    QCircuit Hadamard(qvec q) {
        for (let i=0: 1: q.size()) {
            H(q[i]);
        }
    }

    // U is generated by qc,
    // output U^(2^min)
    QCircuit unitarypower(qvec q, int min, circuitGen qc) {
        for (let i=0: 1: (1 << min)) {
            qc(q);
        }
    }

    QCircuit controlUnitaryPower(qvec q, qubit controlQubit, int min, circuitGen qc) {
        qvec cControlQubit;
        cControlQubit.add(controlQubit);
        unitarypower(q, min, qc).control(cControlQubit);
    }

    QCircuit QPE(qvec controlqvec, qvec targetqvec, circuitGen qc) {
        for(let i=0: 1: controlqvec.size()) {
            H(controlqvec[i]);
        }
        for (let i=0: 1: controlqvec.size()) {
            qubit q = controlqvec[controlqvec.size()-1-i];
            controlUnitaryPower(targetqvec, q, i, qc);
        }
        QFTdagger(controlqvec);
    }  

    @script:
    if __name__ == '__main__':
        init(QMachineType.CPU_SINGLE_THREAD)

        qubit_num = 2
        cbit_num = 2
        cqv = qAlloc_many(qubit_num)   
        tqv = qAlloc_many(1)
        cv = cAlloc_many(cbit_num)
        qpeProg = QProg()
        qpeProg.insert(H(tqv[0]))
        qpeProg.insert(QPE(cqv, tqv, unitary))
        qpeProg.insert(Measure(cqv[0], cv[0]))
        qpeProg.insert(Measure(cqv[1], cv[1]))
        directly_run(qpeProg)
        print("c0: %s" %(cv[0].eval()))
        print("c1: %s" %(cv[1].eval()))

        finalize()

6.9.3 QPE算法小结
-------------------

QPE算法应用了量子傅里叶逆变换，同时作为一个实用的基础量子算法，又被应用在Shor Algorithm（质因式分解算法），和HHL Algorithm（经常用于各种量子机器学习的最优化算法）等等算法中。
